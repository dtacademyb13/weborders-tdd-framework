TDD(Test Driven Development) Framework

Do not confuse TDD with DDT -> DDT(Data-Driven Testing) - Running the same tests with different data inputs. An example is DataProvider.


TDD Framework Building Steps:

1. Create a maven project
2. Add the necessary dependencies
3. Add project specific .gitignore file
4. Create the package structure
5. Add your test cases following the Page Object Model
6. Add xml files for running tests (regression, smoke)
7. Add and configure the Base class
8. Add properties file and ConfigReader Utility class to read from the file
9. Add other utilities (Driver, SeleniumUtils, CSVReader)
10. Add support for command line run of the tests by configuring maven surefire plugin in pom.xml
11. Add headless browser support
12. Add cross browser testing support by adding an option to pass browser from command line
13. Add Extent Reports for pretty html reports
14. Add support for parallel testing




TDD TestNG Framework components:
Java (version 17)-> writing framework code
Maven (3.9.6) -> manage framework structure, dependencies. Execute tests thru command line.
Selenium WebDriver(4.18) -> creating UI tests
TestNG(7.9) -> run the tests, configure and organize tests cases via an xml file and annotations
Faker -> mock data generation
Commons IO - IO operations
IntelliJ -> develop, run, test the framework code, fix the errors, speed up the developement process
Git/GitHub -> version control, remote repository, code collaboration
.gitignore -> ignore unnecessary files to prevent merge conflicts
testng xml file -> configure/organize/group our tests cases
.properties file -> stores project specific global data/variables
utility classes (ConfigReader, Driver, SeleniumUtils) -> store commonly used methods
Test Base Class -> store common setup and teardown operations for all test cases
Lombok - > generates boilerplate code (toString, getter/setters, hashcode and equals) for our page classes through annotations @Data, @AllArgsConstructor, @NoArgsConstructor
Extent Report -> generate a detailed html report for stakeholders


Design Patterns used in this Framework:

Singleton - design pattern applied to Driver class to ensure a single WebDriver instance during the test execution

Page Object Model - design pattern used in UI test frameworks to reduce repeated code and improve maintainability
 Steps:
 - create a class for each page of the app, and add the webelements there with @FindBy annotations
 - Use the page class in your test by creating the object of the class and accessing the webelements through getters or suing the methods
Page Factory - a technique of implementing Page Object Model in a more readable and efficient way:
 We use @FindBy annotations for WebElements and use PageFactory.initElements(Driver.getDriver(), this) in the constructor of the class



Types of tests that this framework supports:

- smoke
- regression
- UI,DB,API tests
- data-driven tests
- cross-browser
- headless
- parallel




Branching Basics:
git branch -> shows the current branch you are at
git branch <name> -> creates a new branch
git checkout <name> -> switches to the branch
git branch -d <name> -> delete the branch, you need to be in other branch to do this



Using Branch Based workflow for Test Automation Framework Code Collaboration:

1. Framework Creation and Initial Push: The team lead creates a test automation
framework and pushes it to his/her remote GitHub repository.
2. Access Provision: The team lead provides push access
to the other team members by adding them as collaborators.
3. Framework Cloning: Each team member clones the test automation framework on
their local machines using the command git clone.
4. Code Update: Each team member pulls the latest code from the main branch to
ensure they're working on the most recent version of the project.
5. Branch Creation: Team members create new branches for implementing their tasks
and switch using git checkout -b branch-name.
6. Implementing Changes: Team members start adding changes and commit those
changes in their respective branches using git commit -m "message".
7. Pushing Changes: Once they've completed their work, team members push their
branches to the remote repository using git push --set-upstream origin branch-
name. This step can be done either through the command line or through IntelliJ
(which requires login to the GitHub account).
8. Pull Request (Merge Request) Creation: Each team member then logs into their GitHub account,
accesses the team repository, and creates a pull request to propose the changes they
made in their branch be merged into main.
9. Code Review and Merge: The assigned reviewer(s) review the pull request and if
everything is fine, they merge the branch into main, close the pull request, and delete
the branch from the remote repository.
10. Local Branch Deletion: After their changes have been merged, team members delete
their old branches locally using git branch -d branch-name.
11. Pull the Main Branch: To get the latest updates that include their and othersâ€™ merged
changes, team members pull the main branch code.
12. Repetition of Steps: Steps 5-11 are repeated for every new task


Git Merge Conflict - it is a conflict when a change that comes from one branch is incompatible with the change that already exists in the current branch

Example merge conflict:

<<<<<<< sprint03
browser=safari

=======
browser=edge
>>>>>>> main

To resolve: choose the change that you want to keep and commit the change in GitHub.

<<<<<<< sprint03  // remove this line
browser=safari      // decide which version to keep

=======           // remove this line
browser=edge      // decide which version to keep
>>>>>>> main       // remove this line

How to avoid merge conflicts?
1. Always pull the latest code from the MAIN branch before adding any new code or creating a new branch
2. Limit working on the common files such as TestBase, .properties etc. Create your own test class for your test code




